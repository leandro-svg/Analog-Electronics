function  scsStripNetlist(scsName)

% SCSSTRIPNETLIST([scsName])
%     Script that strips the spectre input file generated by
%     Cadence (input.scs) from any commands that are not part of
%     the netlist, such as
%       - include models
%       - include graphical stimuli
%       - options
%       - info statements
%       - save statements
%       - simulation statements
%
% JCx, 23-01-2004

% JCx, 05-01-2004
%   First public version
% JCx, 23-01-2004
%   Added header

% initialize
debug = 0;
newline = sprintf('\n');
nextline1 = sprintf('\n+');
nextline2 = sprintf('\\\n');
tab = sprintf('\t');
blank = ' ';

if nargin < 1
    scsName = 'input.scs';
end


% open base file
if ~strncmp(fliplr(scsName), fliplr('.scs'), 4)
    scsName = [scsName '.scs'];
end
fid = fopen(scsName,'r');
if fid < 0
    fprintf('Error opening file %s', scsName)
    status = -1;
    return
end
scsString = char(fread(fid)');
oldString = scsString;
fclose(fid);
if debug
    fprintf('#### original file : %s ####\n', scsName)
    disp(oldString);
    fprintf('####  end of file  ####\n');
    fprintf('\n\n');
end


% add header
header = sprintf('//Generated by matlab, %s\n\n', datestr(now));
scsString = [header scsString];


% remove model statement
s1 = sprintf('\ninclude "models"\n');
f1 = findstr(scsString, s1);
switch length(f1)
    case 0      
        %fprintf('Warning: no statement ''include "models"'' found\n');
    case 1
        f1 = f1+1;
        f2 = f1+length(s1)-2;
        if debug
            fprintf('Removing:\n%s##\n', scsString(f1:f2));
        end
        scsString = [scsString(1:f1-1) scsString(f2+1:end)];
    otherwise
        fprintf('Error in searching ''include "models"'' in file:\n%s\n', scsString);
end

% remove graphical stimuli
s2 = sprintf('/_graphical_stimuli.scs"\n');
f2 = findstr(scsString, s2);
switch length(f1)
    case 0      
        %fprintf('Warning: no graphical stimuli found\n');
    case 1
        % begin
        s1 = sprintf('\ninclude ');
        f1 = findstr(scsString, s1);
        f1 = max(f1(find(f1<f2))) + 1;
        % end
        f2 = f2+length(s2)-1;
        % strip
        if debug
            fprintf('Removing:\n%s##\n', scsString(f1:f2));
        end
        scsString = [scsString(1:f1-1) scsString(f2+1:end)];
    otherwise
        fprintf('Error in searching graphical stimuli in file:\n%s\n', scsString);
end

% remove options
[f1,f2] = scsFindStatement_2(scsString, 'options');
for i=length(f1):-1:1
    if debug
        fprintf('Removing:\n%s##\n', scsString(f1(i):f2(i)));
    end
    scsString = [scsString(1:f1(i)-1) scsString(f2(i)+1:end)];
end

% remove info
[f1,f2] = scsFindStatement_2(scsString, 'info');
for i=length(f1):-1:1
    if debug
        fprintf('Removing:\n%s##\n', scsString(f1(i):f2(i)));
    end
    scsString = [scsString(1:f1(i)-1) scsString(f2(i)+1:end)];
end

% remove global statement
[f1,f2] = scsFindStatement_2(scsString, 'global');
for i=length(f1):-1:1
    if debug
        fprintf('Removing:\n%s##\n', scsString(f1(i):f2(i)));
    end
    scsString = [scsString(1:f1(i)-1) scsString(f2(i)+1:end)];
end

% remove save
[f1,f2] = scsFindStatement_1(scsString, 'save');
for i=length(f1):-1:1
    if debug
        fprintf('Removing:\n%s##\n', scsString(f1(i):f2(i)));
    end
    scsString = [scsString(1:f1(i)-1) scsString(f2(i)+1:end)];
end

% remove simulations
f1 = []; f2 = [];
[t1,t2] = scsFindStatement_2(scsString, 'ac');       f1 = [f1 t1]; f2 = [f2 t2];
[t1,t2] = scsFindStatement_2(scsString, 'dc');       f1 = [f1 t1]; f2 = [f2 t2];
[t1,t2] = scsFindStatement_2(scsString, 'envlp');    f1 = [f1 t1]; f2 = [f2 t2];
[t1,t2] = scsFindStatement_2(scsString, 'noise');    f1 = [f1 t1]; f2 = [f2 t2];
[t1,t2] = scsFindStatement_2(scsString, 'pac');      f1 = [f1 t1]; f2 = [f2 t2];
[t1,t2] = scsFindStatement_2(scsString, 'pdisto');   f1 = [f1 t1]; f2 = [f2 t2];
[t1,t2] = scsFindStatement_2(scsString, 'pnoise');   f1 = [f1 t1]; f2 = [f2 t2];
[t1,t2] = scsFindStatement_2(scsString, 'psp');      f1 = [f1 t1]; f2 = [f2 t2];
[t1,t2] = scsFindStatement_2(scsString, 'pss');      f1 = [f1 t1]; f2 = [f2 t2];
[t1,t2] = scsFindStatement_2(scsString, 'pxf');      f1 = [f1 t1]; f2 = [f2 t2];
[t1,t2] = scsFindStatement_2(scsString, 'qpac');     f1 = [f1 t1]; f2 = [f2 t2];
[t1,t2] = scsFindStatement_2(scsString, 'qpnoise');  f1 = [f1 t1]; f2 = [f2 t2];
[t1,t2] = scsFindStatement_2(scsString, 'qpss');     f1 = [f1 t1]; f2 = [f2 t2];
[t1,t2] = scsFindStatement_2(scsString, 'qpxf');     f1 = [f1 t1]; f2 = [f2 t2];
[t1,t2] = scsFindStatement_2(scsString, 'sp');       f1 = [f1 t1]; f2 = [f2 t2];
[t1,t2] = scsFindStatement_2(scsString, 'tdr');      f1 = [f1 t1]; f2 = [f2 t2];
[t1,t2] = scsFindStatement_2(scsString, 'tran');     f1 = [f1 t1]; f2 = [f2 t2];
[t1,t2] = scsFindStatement_2(scsString, 'xf');       f1 = [f1 t1]; f2 = [f2 t2];
for i=length(f1):-1:1
    if debug
        fprintf('Removing:\n%s##\n', scsString(f1(i):f2(i)));
    end
    scsString = [scsString(1:f1(i)-1) scsString(f2(i)+1:end)];
end


% dump new string into file
if strcmp(scsString,oldString)
    if debug
        fprintf('No lines removed in file %s\n', scsName)
    end
else
    if debug
        fprintf('\n\n');
        fprintf('####  new file:  ####\n');
        disp(scsString);
        fprintf('####  end of file  ####');
    end
    fid = sprintf('%s', scsName);
    fid = fopen(fid, 'w');
    fprintf(fid, '%s', scsString);
    fclose(fid);
end



% =========================================================================

function [begin, einde] = scsFindStatement_1(scsString, statement)

% [begin, einde] = scsFindStatement_1(scsString,statement)
%
% searches through the spectre-syntax string "scsString" looking for the
% spectre statement "statement" and returns the positions of correct
% matches
% "statement" must be the FIRST word of a line
%
%   begin = vector with begin position
%   einde = vector with end position (newline character)


% initialise
debug = 0;
newline = sprintf('\n');
nextline1 = sprintf('\n+');
nextline2 = sprintf('\\\n');
tab = sprintf('\t');
blank = ' ';

if debug
    fprintf('search statement "%s"\n', statement)
end

% replace tabs and nextlines
scsString = strrep(scsString, tab, char(blank*ones(size(tab))));
scsString = strrep(scsString, nextline1, char(blank*ones(size(nextline1))));
scsString = strrep(scsString, nextline2, char(blank*ones(size(nextline2))));


% first search
% . . statement followed by space
s1 = [statement blank];
f1 = findstr(scsString,s1);
% . . statement followed by newline
s1 = [statement newline];
f1 = sort([f1 findstr(scsString,s1)]);
if debug > 1
    f1
end

% validate search results: must be preceded by a newline, or be the first
%     character of the string
for i = 1:length(f1)
    if f1(i) == 1
        % . . first char, ok
    else
        % . . check for newline
        if ~strcmp(scsString(f1(i)-1), newline)
            f1(i) = 0;
        end
    end
end

% resulting correct matches
begin = f1(find(f1~=0));


% Search end-of-line statements
% . . search end-of-line
f2 = findstr(scsString, newline);
% . . add end-of-string
f2 = [f2 length(scsString)];

% construct einde-vector
einde = [];
for i=1:length(begin)
    einde(i) = f2(min(find(f2 - begin(i) > 0)));
    if debug
        fprintf('statement found:\n%s\n',(scsString(begin(i):einde(i))))
    end
end



% =========================================================================

function [begin, einde] = scsFindStatement_2(scsString, statement)

% [begin, einde] = scsFindStatement_2(scsString,statement)
%
% searches through the spectre-syntax string "scsString" looking for the
% spectre statement "statement" and returns the positions of correct
% matches
% "statement" must be the SECOND word of a line
%
%   begin = vector with begin position
%   einde = vector with end position (newline character)


% initialise
debug = 0;
newline = sprintf('\n');
nextline1 = sprintf('\n+');
nextline2 = sprintf('\\\n');
tab = sprintf('\t');
blank = ' ';

if debug
    fprintf('search statement "%s"\n', statement)
end

% replace tabs and nextlines
scsString = strrep(scsString, tab, char(blank*ones(size(tab))));
scsString = strrep(scsString, nextline1, char(blank*ones(size(nextline1))));
scsString = strrep(scsString, nextline2, char(blank*ones(size(nextline2))));


% first search
% . . statement preceded and followed by blank
s1 = [blank statement blank];
f1 = findstr(scsString,s1);
% . . statement preceded by blank and followed by newline
s1 = [blank statement newline];
f1 = sort([f1 findstr(scsString,s1)]);
if debug > 1
    f1
end

% validate search results: the statement must be the second word of a new line.
for i = 1:length(f1)
    pos = f1(i);
    % . . skip leading blanks and tabs
    go = 1;
    while go
        if pos == 1
            prev = scsString(pos);
            go = 0;
        else
            pos = pos-1;
            prev = scsString(pos);
            go = strcmp(prev,blank) | strcmp(prev,tab);
        end
    end
    % . . find preceding newline
    f2 = max([1 findstr(scsString(1:pos), newline)+1]);
    % . . there can't be any blanks between f2 and pos
    if isempty(findstr(scsString(f2:pos), blank))
        % . . ok
        f1(i) = f2;
    else
        % . . not ok
        f1(i) = 0;
    end
end
if debug > 1
    f1
end

% resulting correct matches
begin = f1(find(f1~=0));


% Search end-of-line statements
% . . search end-of-line
f2 = findstr(scsString, newline);
% . . add end-of-string
f2 = [f2 length(scsString)];

% construct einde-vector
einde = [];
for i=1:length(begin)
    einde(i) = f2(min(find(f2 - begin(i) > 0)));
    if debug
        fprintf('statement found:\n%s\n',(scsString(begin(i):einde(i))))
    end
end
